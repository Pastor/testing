use bytes::Buf as _;
use futures::executor::block_on;
use http_auth_basic::Credentials;
use hyper::header::{
    HeaderValue, ACCEPT, AUTHORIZATION, CONTENT_TYPE, COOKIE, ETAG, LAST_MODIFIED, USER_AGENT,
};
use hyper::{Body, Client, HeaderMap, Request, Response};
use hyper_tls::HttpsConnector;
use std::str::FromStr;
use std::time::Duration;

const APPLICATION_JSON: &'static str = "application/json;charset=utf-8";
const APPLICATION_HAL_JSON: &'static str = "application/hal+json;v=2.0";
const APPLICATION_HAL_URLENCODING: &'static str = "application/x-www-form-urlencoded;v=2.0";

type Result<T> = std::result::Result<T, Box<dyn std::error::Error + Send + Sync>>;

pub struct Api {
    url: String,
    username: String,
    password: String,
    cookie: Option<String>,
}

impl Default for Api {
    fn default() -> Self {
        Api::new(
            "https://github.com".to_string(),
            "Default User".to_string(),
            "robotics".to_string(),
        )
    }
}

impl Api {
    pub fn new(url: String, username: String, password: String) -> Self {
        Api {
            url,
            username,
            password,
            cookie: None,
        }
    }

    fn etag(head: &HeaderMap) -> Option<&HeaderValue> {
        head.get(ETAG)
    }

    /// Extract the Last-Modified from the Headers if it exists
    fn last_modified(head: &HeaderMap) -> Option<&HeaderValue> {
        head.get(LAST_MODIFIED)
    }

    /// Extract however many requests the authenticated user can
    /// do from the Headers
    fn rate_limit_remaining(head: &HeaderMap) -> Option<u32> {
        head.get("X-RateLimit-Remaining")
            .map(|limit| u32::from_str(limit.to_str().unwrap_or("")).ok())
            .unwrap_or(None)
    }

    /// Extract however many requests the authenticated user can
    /// make from the Headers
    fn rate_limit(head: &HeaderMap) -> Option<u32> {
        head.get("X-RateLimit-Limit")
            .map(|limit| u32::from_str(limit.to_str().unwrap_or("")).ok())
            .unwrap_or(None)
    }

    /// Extract when the requests limit for the authenticated user
    /// is reset from the Headers
    fn rate_limit_reset(head: &HeaderMap) -> Option<u32> {
        head.get("X-RateLimit-Reset")
            .map(|limit| u32::from_str(limit.to_str().unwrap_or("")).ok())
            .unwrap_or(None)
    }

    fn cookie(head: &HeaderMap) -> Option<String> {
        head.get(COOKIE)
            .map(|cookie| Some(cookie.to_str().unwrap().to_string()))
            .unwrap_or(None)
    }

    fn get(&mut self, path: &'static str) -> Result<Response<Body>> {
        self.request("GET", path, APPLICATION_JSON, Vec::new())
    }

    fn request(
        &mut self,
        method: &'static str,
        path: &'static str,
        content_type: &'static str,
        content: Vec<u8>,
    ) -> Result<Response<Body>> {
        let mut url = self.url.clone();
        if path.len() != 0 {
            url.push_str("/");
            url.push_str(path);
        }
        let mut request = Request::builder()
            .method(method)
            .uri(url)
            .header(CONTENT_TYPE, HeaderValue::from_static(content_type))
            .header(USER_AGENT, HeaderValue::from_static("abb-robo_v1"))
            .header(ACCEPT, HeaderValue::from_static(APPLICATION_HAL_JSON));

        match self.cookie {
            Some(ref value) => request = request.header(COOKIE, value),
            None => {
                let credentials = Credentials::new(
                    self.username.clone().as_str(),
                    self.password.clone().as_str(),
                );
                let credentials = credentials.as_http_header();
                request = request.header(AUTHORIZATION, credentials)
            }
        }
        let body = if content.is_empty() {
            Body::empty()
        } else {
            Body::from(content)
        };
        let request = request.body(body)?;

        let https = HttpsConnector::new();

        let client = Client::builder()
            .pool_idle_timeout(Duration::from_secs(30))
            .http2_only(false)
            .build(https);

        let res = block_on(client.request(request))?;
        self.cookie = Api::cookie(res.headers());
        Ok(res)
    }

    /// https://developercenter.robotstudio.com/api/RWS?urls.primaryName=Mastership%20Service
    pub fn mastership_request(&mut self) -> Result<()> {
        let _res = self.request(
            "POST",
            "/rw/mastership/request",
            APPLICATION_JSON,
            Vec::default(),
        )?;
        Ok(())
    }

    /// https://developercenter.robotstudio.com/api/RWS?urls.primaryName=Mastership%20Service
    pub fn mastership_release(&mut self) -> Result<()> {
        let _res = self.request(
            "POST",
            "/rw/mastership/release",
            APPLICATION_JSON,
            Vec::default(),
        )?;
        Ok(())
    }

    pub fn position(&mut self, pos: &Position) -> Result<()> {
        let _res = self.request(
            "POST",
            "/rw/motionsystem/position-target",
            APPLICATION_HAL_URLENCODING,
            pos.to_string().into_bytes(),
        )?;
        Ok(())
    }

    pub fn jog(&mut self, jog: &Jog) -> Result<()> {
        let _res = self.request(
            "POST",
            "/rw/motionsystem/jog",
            APPLICATION_HAL_URLENCODING,
            jog.to_string().into_bytes(),
        )?;
        Ok(())
    }

    pub fn energy_reset(&mut self) -> Result<()> {
        let _res = self.request(
            "POST",
            "/rw/system/energy/reset",
            APPLICATION_HAL_URLENCODING,
            Vec::default(),
        )?;
        Ok(())
    }

    pub fn users(&mut self) -> Result<Vec<UserInfo>> {
        let res = self.get("/users/login-info")?;
        let buf = block_on(hyper::body::aggregate(res)).unwrap();
        let users = serde_json::from_reader(buf.reader())?;
        tracing::info!("{:#?}", users);
        Ok(users)
    }
}

///https://developercenter.robotstudio.com/api/RWS?urls.primaryName=User%20Service
#[derive(Deserialize, Debug)]
#[serde(rename_all = "kebab-case", deny_unknown_fields)]
pub struct UserInfo {
    uas_id: String,
    user_name: String,
    user_locale: String,
    user_application: String,
    user_location: String,
    user_alias: String,
    comm_port: String,
    user_network_locality: String,
}

/// https://developercenter.robotstudio.com/api/RWS?urls.primaryName=MotionSystem%20Service
/// /rw/motionsystem/position-target
/// pos-x=string&pos-y=string&pos-z=string&orient-q1=string&orient-q2=string&orient-q3=string&orient-q4=string&config-j1=string&config-j4=string&config-j6=string&config-jx=string&extjoint-1=string&extjoint-2=string&extjoint-3=string&extjoint-4=string&extjoint-5=string&extjoint-6=string
/// application/x-www-form-urlencoded;v=2.0
#[derive(Deserialize, Debug)]
#[serde(rename_all = "kebab-case", deny_unknown_fields)]
pub struct Position {
    pos_x: String,
    pos_y: String,
    pos_z: String,
    orient_q1: String,
    orient_q2: String,
    orient_q3: String,
    orient_q4: String,
    config_j1: String,
    config_j4: String,
    config_j6: String,
    config_jx: String,
    extjoint_1: String,
    extjoint_2: String,
    extjoint_3: String,
    extjoint_4: String,
    extjoint_5: String,
    extjoint_6: String,
}

impl ToString for Position {
    fn to_string(&self) -> String {
        let mut res = String::new();
        res.push_str("pos-x=");
        res.push_str(self.pos_x.as_str());
        res.push_str("&");
        res.push_str("pos-y=");
        res.push_str(self.pos_y.as_str());
        res.push_str("&");
        res.push_str("pos-z=");
        res.push_str(self.pos_z.as_str());
        res.push_str("&");
        res.push_str("orient-q1=");
        res.push_str(self.orient_q1.as_str());
        res.push_str("&");
        res.push_str("orient-q2=");
        res.push_str(self.orient_q2.as_str());
        res.push_str("&");
        res.push_str("orient-q3=");
        res.push_str(self.orient_q3.as_str());
        res.push_str("&");
        res.push_str("orient-q4=");
        res.push_str(self.orient_q4.as_str());
        res.push_str("&");
        res.push_str("config-j1=");
        res.push_str(self.config_j1.as_str());
        res.push_str("&");
        res.push_str("config-j4=");
        res.push_str(self.config_j4.as_str());
        res.push_str("&");
        res.push_str("config-j6=");
        res.push_str(self.config_j6.as_str());
        res.push_str("&");
        res.push_str("config-jx=");
        res.push_str(self.config_jx.as_str());
        res.push_str("&");
        res
    }
}

#[derive(Deserialize, Debug)]
#[serde(rename_all = "kebab-case", deny_unknown_fields)]
pub struct Jog {
    axis1: String,
    axis2: String,
    axis3: String,
    axis4: String,
    axis5: String,
    axis6: String,
    ccount: String,
    inc_mode: String,
}

impl ToString for Jog {
    fn to_string(&self) -> String {
        let mut res = String::new();
        res.push_str("axis1=");
        res.push_str(self.axis1.as_str());
        res.push_str("&");
        res.push_str("axis2=");
        res.push_str(self.axis2.as_str());
        res.push_str("&");
        res.push_str("axis3=");
        res.push_str(self.axis3.as_str());
        res.push_str("&");
        res.push_str("axis4=");
        res.push_str(self.axis4.as_str());
        res.push_str("&");
        res.push_str("axis5=");
        res.push_str(self.axis5.as_str());
        res.push_str("&");
        res.push_str("axis6=");
        res.push_str(self.axis6.as_str());
        res.push_str("&");
        res.push_str("ccount=");
        res.push_str(self.ccount.as_str());
        res.push_str("&");
        res.push_str("inc-mode=");
        res.push_str(self.inc_mode.as_str());
        res
    }
}
